"""
Qdrant Vector Database Client for Ingestion Service

Handles vector storage operations for embeddings generated by the embedding service.
"""

import logging
import uuid
from typing import Any

logger = logging.getLogger(__name__)

# Import Qdrant client only when needed to avoid circular imports
try:
    from qdrant_client import QdrantClient
    from qdrant_client.models import (
        Distance,
        FieldCondition,
        Filter,
        MatchValue,
        PointStruct,
        VectorParams,
    )

    QDRANT_AVAILABLE = True
except ImportError:
    QDRANT_AVAILABLE = False
    logger.warning("Qdrant client not available. Install qdrant-client package.")


class QdrantManager:
    """
    Manages Qdrant vector database operations for the ingestion service.
    """

    def __init__(
        self,
        host: str = "localhost",
        port: int = 6333,
        api_key: str | None = None,
        collection_name: str = "embeddings",
        vector_size: int = 384,
    ):
        """
        Initialize Qdrant client.

        Args:
            host: Qdrant server host
            port: Qdrant server port
            api_key: Qdrant API key (if authentication required)
            collection_name: Name of the Qdrant collection
            vector_size: Dimension of embedding vectors
        """
        if not QDRANT_AVAILABLE:
            raise RuntimeError(
                "Qdrant client not available. Install qdrant-client package."
            )

        self.host = host
        self.port = port
        self.api_key = api_key
        self.collection_name = collection_name
        self.vector_size = vector_size

        # Initialize Qdrant client
        try:
            self.client = QdrantClient(host=host, port=port, api_key=api_key)
            logger.info(f"Connected to Qdrant at {host}:{port}")
        except Exception as e:
            logger.error(f"Failed to connect to Qdrant: {e}")
            raise RuntimeError(f"Failed to connect to Qdrant: {str(e)}") from e

        # Ensure collection exists
        self._ensure_collection_exists()

    def _ensure_collection_exists(self):
        """Ensure the Qdrant collection exists with correct configuration."""
        try:
            # Check if collection exists
            collections = self.client.get_collections()
            collection_names = [col.name for col in collections.collections]

            if self.collection_name not in collection_names:
                logger.info(f"Creating Qdrant collection: {self.collection_name}")
                self.client.create_collection(
                    collection_name=self.collection_name,
                    vectors_config=VectorParams(
                        size=self.vector_size, distance=Distance.COSINE
                    ),
                )
                logger.info(f"Collection {self.collection_name} created successfully")
            else:
                logger.info(f"Collection {self.collection_name} already exists")

        except Exception as e:
            logger.error(f"Failed to ensure collection exists: {e}")
            raise

    def _is_valid_uuid(self, uuid_string: str) -> bool:
        """
        Check if a string is a valid UUID format.

        Args:
            uuid_string: String to validate

        Returns:
            True if valid UUID, False otherwise
        """
        try:
            uuid.UUID(uuid_string)
            return True
        except (ValueError, TypeError):
            return False

    def store_embedding(
        self,
        text: str,
        embedding: list[float],
        document_id: str,
        metadata: dict[str, Any | None] = None,
        point_id: str | None = None,
    ) -> str:
        """
        Store an embedding in Qdrant.

        Args:
            text: Original text that was embedded
            embedding: Embedding vector
            document_id: Document identifier
            metadata: Additional metadata
            point_id: Optional specific point ID

        Returns:
            Point ID of the stored embedding
        """
        try:
            # Generate point ID if not provided
            if not point_id:
                point_id = str(uuid.uuid4())
            elif not self._is_valid_uuid(point_id):
                # If provided point_id is not a valid UUID, generate a new one
                point_id = str(uuid.uuid4())

            # Prepare metadata
            point_metadata = {
                "text": text,
                "document_id": document_id,
                "text_length": len(text),
            }

            if metadata:
                point_metadata.update(metadata)

            # Create point
            point = PointStruct(id=point_id, vector=embedding, payload=point_metadata)

            # Store in Qdrant
            self.client.upsert(collection_name=self.collection_name, points=[point])

            logger.info(
                f"Stored embedding for document {document_id} with point ID {point_id}"
            )
            return point_id

        except Exception as e:
            logger.error(f"Failed to store embedding for document {document_id}: {e}")
            raise

    def store_chunked_embeddings(
        self,
        chunks: list[dict[str, Any]],
        document_id: str,
        metadata: dict[str, Any | None] = None,
    ) -> list[str]:
        """
        Store multiple chunked embeddings for a document.

        Args:
            chunks: List of chunk data with 'text', 'embedding', and optional 'chunk_id'
            document_id: Document identifier
            metadata: Additional metadata for all chunks

        Returns:
            List of point IDs for stored embeddings
        """
        try:
            points = []
            point_ids = []

            for i, chunk in enumerate(chunks):
                # Generate point ID if not provided
                # Ensure point ID is a valid UUID format for Qdrant
                chunk_id = chunk.get("chunk_id")
                if chunk_id and self._is_valid_uuid(chunk_id):
                    point_id = chunk_id
                else:
                    point_id = str(uuid.uuid4())
                point_ids.append(point_id)

                # Prepare chunk metadata
                chunk_metadata = {
                    "text": chunk["text"],
                    "document_id": document_id,
                    "chunk_index": i,
                    "chunk_id": point_id,
                    "text_length": len(chunk["text"]),
                    "total_chunks": len(chunks),
                }

                if metadata:
                    chunk_metadata.update(metadata)

                # Create point
                point = PointStruct(
                    id=point_id, vector=chunk["embedding"], payload=chunk_metadata
                )
                points.append(point)

            # Store all points in batch
            self.client.upsert(collection_name=self.collection_name, points=points)

            logger.info(
                f"Stored {len(chunks)} chunked embeddings for document {document_id}"
            )
            return point_ids

        except Exception as e:
            logger.error(
                f"Failed to store chunked embeddings for document {document_id}: {e}"
            )
            raise

    def search_similar(
        self,
        query_embedding: list[float],
        limit: int = 10,
        score_threshold: float = 0.0,
        filter_conditions: dict[str, Any | None] = None,
    ) -> list[dict[str, Any]]:
        """
        Search for similar embeddings.

        Args:
            query_embedding: Query embedding vector
            limit: Maximum number of results
            score_threshold: Minimum similarity score
            filter_conditions: Optional metadata filters

        Returns:
            List of similar documents with scores
        """
        try:
            # Prepare filter
            search_filter = None
            if filter_conditions:
                conditions = []
                for key, value in filter_conditions.items():
                    conditions.append(
                        FieldCondition(key=key, match=MatchValue(value=value))
                    )
                search_filter = Filter(must=conditions)

            # Perform search
            search_results = self.client.search(
                collection_name=self.collection_name,
                query_vector=query_embedding,
                limit=limit,
                score_threshold=score_threshold,
                query_filter=search_filter,
            )

            # Format results
            results = []
            for result in search_results:
                results.append(
                    {
                        "point_id": result.id,
                        "score": result.score,
                        "text": result.payload.get("text", ""),
                        "document_id": result.payload.get("document_id", ""),
                        "metadata": result.payload,
                    }
                )

            logger.info(f"Found {len(results)} similar documents")
            return results

        except Exception as e:
            logger.error(f"Failed to search similar embeddings: {e}")
            raise

    def delete_document_embeddings(self, document_id: str) -> int:
        """
        Delete all embeddings for a specific document.

        Args:
            document_id: Document identifier

        Returns:
            Number of deleted embeddings
        """
        try:
            # Create filter for document_id
            filter_condition = Filter(
                must=[
                    FieldCondition(
                        key="document_id", match=MatchValue(value=document_id)
                    )
                ]
            )

            # Delete points
            result = self.client.delete(
                collection_name=self.collection_name, points_selector=filter_condition
            )

            logger.info(f"Deleted embeddings for document {document_id}")
            return result.operation_id

        except Exception as e:
            logger.error(f"Failed to delete embeddings for document {document_id}: {e}")
            raise

    def get_collection_info(self) -> dict[str, Any]:
        """
        Get information about the collection.

        Returns:
            Collection metadata and statistics
        """
        try:
            info = self.client.get_collection(self.collection_name)

            return {
                "collection_name": self.collection_name,
                "vector_size": info.config.params.vectors.size,
                "distance": info.config.params.vectors.distance,
                "points_count": info.points_count,
                "indexed_vectors_count": info.indexed_vectors_count,
                "status": info.status,
            }

        except Exception as e:
            logger.error(f"Failed to get collection info: {e}")
            raise

    def health_check(self) -> dict[str, bool]:
        """
        Check Qdrant health status.

        Returns:
            Health status dictionary
        """
        try:
            # Try to get collections to check connection
            self.client.get_collections()

            # Check if our collection exists
            collections = self.client.get_collections()
            collection_exists = self.collection_name in [
                col.name for col in collections.collections
            ]

            return {"qdrant_available": True, "collection_exists": collection_exists}

        except Exception as e:
            logger.error(f"Qdrant health check failed: {e}")
            return {"qdrant_available": False, "collection_exists": False}


# Global Qdrant manager instance
_qdrant_manager: QdrantManager | None = None


def get_qdrant_manager() -> QdrantManager:
    """
    Get the global Qdrant manager instance.

    Returns:
        QdrantManager instance
    """
    global _qdrant_manager
    if _qdrant_manager is None:
        raise RuntimeError(
            "Qdrant manager not initialized. Call initialize_qdrant_manager() first."
        )
    return _qdrant_manager


def initialize_qdrant_manager(
    host: str = "localhost",
    port: int = 6333,
    api_key: str | None = None,
    collection_name: str = "embeddings",
    vector_size: int = 384,
) -> QdrantManager:
    """
    Initialize the global Qdrant manager.

    Args:
        host: Qdrant server host
        port: Qdrant server port
        api_key: Qdrant API key
        collection_name: Collection name
        vector_size: Vector dimension

    Returns:
        Initialized QdrantManager instance
    """
    global _qdrant_manager
    _qdrant_manager = QdrantManager(
        host=host,
        port=port,
        api_key=api_key,
        collection_name=collection_name,
        vector_size=vector_size,
    )
    return _qdrant_manager
